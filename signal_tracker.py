"""
Live signal tracking and self-evaluation for AI Pump/Dump bot

This module keeps track of signals that were sent to the user and then
monitors price action afterwards to determine whether the signal was
correct (TP hit), wrong (SL hit) or inconclusive (timeout).

It also produces aggregated statistics that can be used for daily
reports and simple self-repair logic.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Dict, Optional

import config


@dataclass
class TrackedSignal:
    """Represents a single live signal that we want to evaluate later."""
    id: int
    symbol: str
    signal_type: str  # "PUMP" or "DUMP"
    timestamp: datetime
    entry: float
    exit1: float
    exit2: float
    exit3: float
    stop_loss: float
    probability: float
    confidence: float
    # Optional feature vector used for training (dict of feature_name -> value)
    features: Optional[Dict[str, float]] = None
    status: str = "open"  # "open", "win", "loss", "timeout"
    hit_target: Optional[int] = None  # 1, 2, 3 or None
    close_time: Optional[datetime] = None
    close_price: Optional[float] = None


class SignalTracker:
    """
    Tracks all signals generated by the bot and evaluates them over time.
    """

    def __init__(self, max_lifetime_hours: int = 4):
        # Active (open) signals that are still being evaluated
        self.active_signals: Dict[int, TrackedSignal] = {}
        # All signals including closed ones, for statistics
        self.history: List[TrackedSignal] = []
        self._next_id = 1
        self.max_lifetime = timedelta(hours=max_lifetime_hours)

    def add_signal(self, analysis: Dict) -> int:
        """
        Register a new signal based on the analysis dict used for Telegram alerts.
        Returns internal signal id.
        """
        signal_id = self._next_id
        self._next_id += 1

        ts = analysis.get("timestamp", datetime.now())
        tracked = TrackedSignal(
            id=signal_id,
            symbol=analysis["symbol"],
            signal_type=analysis.get("signal_type", "PUMP"),
            timestamp=ts,
            entry=float(analysis.get("entry", analysis.get("current_price", 0.0))),
            exit1=float(analysis.get("exit1", 0.0)),
            exit2=float(analysis.get("exit2", 0.0)),
            exit3=float(analysis.get("exit3", 0.0)),
            stop_loss=float(analysis.get("stop_loss", 0.0)),
            probability=float(analysis.get("signal_probability", 0.0)),
            confidence=float(analysis.get("confidence", 0.0)),
            features=analysis.get("features"),
        )

        self.active_signals[signal_id] = tracked
        self.history.append(tracked)
        return signal_id

    def update_with_price(self, symbol: str, price: float, now: Optional[datetime] = None) -> List[TrackedSignal]:
        """
        Update all active signals for a given symbol with the latest price.
        Returns list of signals that have just been closed (win/loss/timeout).
        """
        if now is None:
            now = datetime.now()

        closed: List[TrackedSignal] = []

        for signal_id, sig in list(self.active_signals.items()):
            if sig.symbol != symbol or sig.status != "open":
                continue

            # Resolve current price (handle cases where caller passes None)
            # If no fresh price is available, fall back to last known/entry price
            current_price = price
            if current_price is None:
                current_price = sig.close_price if sig.close_price is not None else sig.entry

            # Check hard timeout first (absolute maximum lifetime)
            if now - sig.timestamp > self.max_lifetime:
                sig.status = "timeout"
                sig.close_time = now
                sig.close_price = current_price
                closed.append(sig)
                del self.active_signals[signal_id]
                continue

            # Early-timeout logic: if price is almost unchanged for a long time,
            # close signal as timeout instead of keeping it open for hours.
            if getattr(config, "EARLY_TIMEOUT_ENABLED", True):
                elapsed = now - sig.timestamp
                min_hours = getattr(config, "EARLY_TIMEOUT_MIN_HOURS", 1.5)
                max_move_pct = getattr(config, "EARLY_TIMEOUT_MAX_MOVE_PCT", 0.02)
                if sig.entry:
                    move_pct = abs(current_price - sig.entry) / sig.entry
                else:
                    move_pct = 0.0

                if elapsed > timedelta(hours=min_hours) and move_pct < max_move_pct:
                    sig.status = "timeout"
                    sig.close_time = now
                    sig.close_price = current_price
                    closed.append(sig)
                    del self.active_signals[signal_id]
                    continue

            # For PUMP: win if price reaches any TP above entry before SL below entry
            # For DUMP: win if price reaches any TP below entry before SL above entry
            if sig.signal_type == "PUMP":
                # Check stop loss first (down move)
                if current_price <= sig.stop_loss:
                    sig.status = "loss"
                    sig.hit_target = None
                    sig.close_time = now
                    sig.close_price = price
                    closed.append(sig)
                    del self.active_signals[signal_id]
                    continue

                # Then check targets from nearest to farthest
                if current_price >= sig.exit1:
                    target_hit = 1
                    if current_price >= sig.exit2:
                        target_hit = 2
                    if current_price >= sig.exit3:
                        target_hit = 3

                    sig.status = "win"
                    sig.hit_target = target_hit
                    sig.close_time = now
                    sig.close_price = current_price
                    closed.append(sig)
                    del self.active_signals[signal_id]
                    continue

            elif sig.signal_type == "DUMP":
                # For dumps, price going UP hits SL, going DOWN hits targets
                if current_price >= sig.stop_loss:
                    sig.status = "loss"
                    sig.hit_target = None
                    sig.close_time = now
                    sig.close_price = price
                    closed.append(sig)
                    del self.active_signals[signal_id]
                    continue

                if current_price <= sig.exit1:
                    target_hit = 1
                    if current_price <= sig.exit2:
                        target_hit = 2
                    if current_price <= sig.exit3:
                        target_hit = 3

                    sig.status = "win"
                    sig.hit_target = target_hit
                    sig.close_time = now
                    sig.close_price = current_price
                    closed.append(sig)
                    del self.active_signals[signal_id]
                    continue

        return closed

    def get_daily_stats(self, day: Optional[datetime] = None) -> Dict:
        """
        Compute statistics for a specific calendar day (UTC by default).
        """
        if day is None:
            day = datetime.utcnow()

        day_str = day.strftime("%Y-%m-%d")
        total = 0
        wins = 0
        losses = 0
        timeouts = 0
        pump_signals = 0
        dump_signals = 0

        for sig in self.history:
            if sig.timestamp.strftime("%Y-%m-%d") != day_str:
                continue
            total += 1
            if sig.signal_type == "PUMP":
                pump_signals += 1
            else:
                dump_signals += 1

            if sig.status == "win":
                wins += 1
            elif sig.status == "loss":
                losses += 1
            elif sig.status == "timeout":
                timeouts += 1

        win_rate = (wins / total) if total > 0 else 0.0

        return {
            "date": day_str,
            "total_signals": total,
            "wins": wins,
            "losses": losses,
            "timeouts": timeouts,
            "win_rate": win_rate,
            "pump_signals": pump_signals,
            "dump_signals": dump_signals,
        }

    def get_symbol_stats(self, symbol: str, days: int = 7) -> Dict:
        """
        Compute recent performance statistics for a specific symbol over the last N days.
        """
        cutoff = datetime.utcnow() - timedelta(days=days)
        total = 0
        wins = 0
        losses = 0
        timeouts = 0
        total_profit = 0.0
        avg_profit_per_trade = 0.0

        # Iterate from the end (most recent first) for efficiency
        for sig in reversed(self.history):
            if sig.symbol != symbol:
                continue
            if sig.timestamp < cutoff:
                break

            total += 1
            if sig.status == "win":
                wins += 1
                # Calculate profit for wins
                if sig.signal_type == "PUMP" and sig.close_price and sig.entry:
                    profit_pct = (sig.close_price - sig.entry) / sig.entry
                elif sig.signal_type == "DUMP" and sig.close_price and sig.entry:
                    profit_pct = (sig.entry - sig.close_price) / sig.entry
                else:
                    profit_pct = 0.0
                total_profit += profit_pct * 100  # Assume 100 USDT position
            elif sig.status == "loss":
                losses += 1
                # Calculate loss
                if sig.signal_type == "PUMP" and sig.close_price and sig.entry:
                    profit_pct = (sig.close_price - sig.entry) / sig.entry
                elif sig.signal_type == "DUMP" and sig.close_price and sig.entry:
                    profit_pct = (sig.entry - sig.close_price) / sig.entry
                else:
                    profit_pct = 0.0
                total_profit += profit_pct * 100
            elif sig.status == "timeout":
                timeouts += 1

        win_rate = (wins / total) if total > 0 else 0.0
        avg_profit_per_trade = total_profit / total if total > 0 else 0.0

        return {
            "symbol": symbol,
            "total_signals": total,
            "wins": wins,
            "losses": losses,
            "timeouts": timeouts,
            "win_rate": win_rate,
            "total_profit": total_profit,
            "avg_profit_per_trade": avg_profit_per_trade,
        }
    
    def get_blacklist_candidates(self, min_signals: int = 5, 
                                min_win_rate: float = 0.3,
                                min_profit: float = -50.0) -> List[str]:
        """
        Get list of symbols that should be blacklisted based on poor performance
        """
        symbol_stats = {}
        cutoff = datetime.utcnow() - timedelta(days=7)
        
        for sig in self.history:
            if sig.timestamp < cutoff:
                continue
            if sig.symbol not in symbol_stats:
                symbol_stats[sig.symbol] = {
                    'total': 0, 'wins': 0, 'losses': 0, 
                    'timeouts': 0, 'profit': 0.0
                }
            
            stats = symbol_stats[sig.symbol]
            stats['total'] += 1
            if sig.status == "win":
                stats['wins'] += 1
            elif sig.status == "loss":
                stats['losses'] += 1
            elif sig.status == "timeout":
                stats['timeouts'] += 1
            
            # Calculate profit
            if sig.close_price and sig.entry:
                if sig.signal_type == "PUMP":
                    profit_pct = (sig.close_price - sig.entry) / sig.entry
                else:
                    profit_pct = (sig.entry - sig.close_price) / sig.entry
                stats['profit'] += profit_pct * 100
        
        blacklist = []
        for symbol, stats in symbol_stats.items():
            if stats['total'] < min_signals:
                continue
            
            win_rate = stats['wins'] / stats['total'] if stats['total'] > 0 else 0.0
            if win_rate < min_win_rate and stats['profit'] < min_profit:
                blacklist.append(symbol)
        
        return blacklist


